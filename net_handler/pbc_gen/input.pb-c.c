/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: input.proto */

/* Do not generate deprecated warnings for self */
#ifndef PROTOBUF_C__NO_DEPRECATED
#define PROTOBUF_C__NO_DEPRECATED
#endif

#include "input.pb-c.h"
void input__init(Input* message) {
    static const Input init_value = INPUT__INIT;
    *message = init_value;
}
size_t input__get_packed_size(const Input* message) {
    assert(message->base.descriptor == &input__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*) (message));
}
size_t input__pack(const Input* message,
                   uint8_t* out) {
    assert(message->base.descriptor == &input__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*) message, out);
}
size_t input__pack_to_buffer(const Input* message,
                             ProtobufCBuffer* buffer) {
    assert(message->base.descriptor == &input__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*) message, buffer);
}
Input*
input__unpack(ProtobufCAllocator* allocator,
              size_t len,
              const uint8_t* data) {
    return (Input*)
        protobuf_c_message_unpack(&input__descriptor,
                                  allocator, len, data);
}
void input__free_unpacked(Input* message,
                          ProtobufCAllocator* allocator) {
    if (!message)
        return;
    assert(message->base.descriptor == &input__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*) message, allocator);
}
void user_inputs__init(UserInputs* message) {
    static const UserInputs init_value = USER_INPUTS__INIT;
    *message = init_value;
}
size_t user_inputs__get_packed_size(const UserInputs* message) {
    assert(message->base.descriptor == &user_inputs__descriptor);
    return protobuf_c_message_get_packed_size((const ProtobufCMessage*) (message));
}
size_t user_inputs__pack(const UserInputs* message,
                         uint8_t* out) {
    assert(message->base.descriptor == &user_inputs__descriptor);
    return protobuf_c_message_pack((const ProtobufCMessage*) message, out);
}
size_t user_inputs__pack_to_buffer(const UserInputs* message,
                                   ProtobufCBuffer* buffer) {
    assert(message->base.descriptor == &user_inputs__descriptor);
    return protobuf_c_message_pack_to_buffer((const ProtobufCMessage*) message, buffer);
}
UserInputs*
user_inputs__unpack(ProtobufCAllocator* allocator,
                    size_t len,
                    const uint8_t* data) {
    return (UserInputs*)
        protobuf_c_message_unpack(&user_inputs__descriptor,
                                  allocator, len, data);
}
void user_inputs__free_unpacked(UserInputs* message,
                                ProtobufCAllocator* allocator) {
    if (!message)
        return;
    assert(message->base.descriptor == &user_inputs__descriptor);
    protobuf_c_message_free_unpacked((ProtobufCMessage*) message, allocator);
}
static const ProtobufCFieldDescriptor input__field_descriptors[4] =
    {
        {
            "connected",
            1,
            PROTOBUF_C_LABEL_NONE,
            PROTOBUF_C_TYPE_BOOL,
            0, /* quantifier_offset */
            offsetof(Input, connected),
            NULL,
            NULL,
            0,            /* flags */
            0, NULL, NULL /* reserved1,reserved2, etc */
        },
        {
            "buttons",
            2,
            PROTOBUF_C_LABEL_NONE,
            PROTOBUF_C_TYPE_FIXED64,
            0, /* quantifier_offset */
            offsetof(Input, buttons),
            NULL,
            NULL,
            0,            /* flags */
            0, NULL, NULL /* reserved1,reserved2, etc */
        },
        {
            "axes",
            3,
            PROTOBUF_C_LABEL_REPEATED,
            PROTOBUF_C_TYPE_FLOAT,
            offsetof(Input, n_axes),
            offsetof(Input, axes),
            NULL,
            NULL,
            0 | PROTOBUF_C_FIELD_FLAG_PACKED, /* flags */
            0, NULL, NULL                     /* reserved1,reserved2, etc */
        },
        {
            "source",
            4,
            PROTOBUF_C_LABEL_NONE,
            PROTOBUF_C_TYPE_ENUM,
            0, /* quantifier_offset */
            offsetof(Input, source),
            &source__descriptor,
            NULL,
            0,            /* flags */
            0, NULL, NULL /* reserved1,reserved2, etc */
        },
};
static const unsigned input__field_indices_by_name[] = {
    2, /* field[2] = axes */
    1, /* field[1] = buttons */
    0, /* field[0] = connected */
    3, /* field[3] = source */
};
static const ProtobufCIntRange input__number_ranges[1 + 1] =
    {
        {1, 0},
        {0, 4}};
const ProtobufCMessageDescriptor input__descriptor =
    {
        PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
        "Input",
        "Input",
        "Input",
        "",
        sizeof(Input),
        4,
        input__field_descriptors,
        input__field_indices_by_name,
        1, input__number_ranges,
        (ProtobufCMessageInit) input__init,
        NULL, NULL, NULL /* reserved[123] */
};
static const ProtobufCFieldDescriptor user_inputs__field_descriptors[1] =
    {
        {
            "inputs",
            1,
            PROTOBUF_C_LABEL_REPEATED,
            PROTOBUF_C_TYPE_MESSAGE,
            offsetof(UserInputs, n_inputs),
            offsetof(UserInputs, inputs),
            &input__descriptor,
            NULL,
            0,            /* flags */
            0, NULL, NULL /* reserved1,reserved2, etc */
        },
};
static const unsigned user_inputs__field_indices_by_name[] = {
    0, /* field[0] = inputs */
};
static const ProtobufCIntRange user_inputs__number_ranges[1 + 1] =
    {
        {1, 0},
        {0, 1}};
const ProtobufCMessageDescriptor user_inputs__descriptor =
    {
        PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
        "UserInputs",
        "UserInputs",
        "UserInputs",
        "",
        sizeof(UserInputs),
        1,
        user_inputs__field_descriptors,
        user_inputs__field_indices_by_name,
        1, user_inputs__number_ranges,
        (ProtobufCMessageInit) user_inputs__init,
        NULL, NULL, NULL /* reserved[123] */
};
static const ProtobufCEnumValue source__enum_values_by_number[2] =
    {
        {"GAMEPAD", "SOURCE__GAMEPAD", 0},
        {"KEYBOARD", "SOURCE__KEYBOARD", 1},
};
static const ProtobufCIntRange source__value_ranges[] = {
    {0, 0}, {0, 2}};
static const ProtobufCEnumValueIndex source__enum_values_by_name[2] =
    {
        {"GAMEPAD", 0},
        {"KEYBOARD", 1},
};
const ProtobufCEnumDescriptor source__descriptor =
    {
        PROTOBUF_C__ENUM_DESCRIPTOR_MAGIC,
        "Source",
        "Source",
        "Source",
        "",
        2,
        source__enum_values_by_number,
        2,
        source__enum_values_by_name,
        1,
        source__value_ranges,
        NULL, NULL, NULL, NULL /* reserved[1234] */
};
